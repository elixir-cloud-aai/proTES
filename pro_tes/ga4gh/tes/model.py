# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2022-06-21T20:10:31+00:00

from __future__ import annotations

from enum import Enum
from typing import Dict, List, Optional

from pydantic import BaseModel, Field


class TesCancelTaskResponse(BaseModel):
    pass


class TesCreateTaskResponse(BaseModel):
    id: str = Field(..., description='Task identifier assigned by the server.')


class TesExecutor(BaseModel):
    image: str = Field(
        ...,
      description='Name of the container image, for example:\nubuntu\nquay.io/aptible/ubuntu\ngcr.io/my-org/my-image\netc...',
    )
    command: List[str] = Field(
        ...,
        description='A sequence of program arguments to execute,   where the first argument\nis the program to execute (i.e. argv).',
    )
    workdir: Optional[str] = Field(
        None,
        description='The working directory that the command will be executed in.\n Defaults to the directory set by the container image.',
    )
    stdin: Optional[str] = Field(
        None,
        description="Path inside the container to a file which will be piped\nto the executor's stdin. Must be an absolute path.",
    )
    stdout: Optional[str] = Field(
        None,
        description="Path inside the container to a file where   the executor's\nstdout will be written to. Must be an absolute path.",
    )
    stderr: Optional[str] = Field(
        None,
        description="Path inside the container to a file where the executor's\nstderr will be written to. Must be an absolute path.",
    )
    env: Optional[Dict[str, str]] = Field(
        None, description='Enviromental variables to set within the container.'
    )


class TesExecutorLog(BaseModel):
    start_time: Optional[str] = Field(
        None, description='Time the executor started, in RFC 3339 format.'
    )
    end_time: Optional[str] = Field(
        None, description='Time the executor ended, in RFC 3339 format.'
    )
    stdout: Optional[str] = Field(
        None,
        description='Stdout content.\n\nThis is meant for convenience. No guarantees are made about the content.\nImplementations may chose different approaches: only the head, only the tail,\na URL reference only, etc.\n\nIn order to capture the full stdout users should set Executor.stdout\nto a container file path, and use Task.outputs to upload that file\nto permanent storage.',
    )
    stderr: Optional[str] = Field(
        None,
        description='Stderr content.\n\nThis is meant for convenience. No guarantees are made about the content.\nImplementations may chose different approaches: only the head, only the tail,\na URL reference only, etc.\n\nIn order to capture the full stderr users should set Executor.stderr\nto a container file path, and use Task.outputs to upload that file\nto permanent storage.',
    )
    exit_code: int = Field(..., description='Exit code.')


class TesFileType(Enum):
    FILE = 'FILE'
    DIRECTORY = 'DIRECTORY'


class TesInput(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    url: Optional[str] = Field(
        None,
        description='REQUIRED, unless "content" is set.\n\nURL in long term storage, for example:\ns3://my-object-store/file1\ngs://my-bucket/file2\nfile:///path/to/my/file\n/path/to/my/file\netc...',
    )
    path: str = Field(
        ...,
        description='Path of the file inside the container.\nMust be an absolute path.',
    )
    type: TesFileType = Field(..., description='Type of the file, FILE or DIRECTORY')
    content: Optional[str] = Field(
        None,
        description='File content literal. \nImplementations should support a minimum of 128 KiB in this field and may define its own maximum.\nUTF-8 encoded\n\nIf content is not empty, "url" must be ignored.',
    )


class TesOutput(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    url: str = Field(
        ...,
        description='URL in long term storage, for example:\ns3://my-object-store/file1\ngs://my-bucket/file2\nfile:///path/to/my/file\n/path/to/my/file\netc...',
    )
    path: str = Field(
        ...,
        description='Path of the file inside the container.\nMust be an absolute path.',
    )
    type: TesFileType = Field(..., description='Type of the file, FILE or DIRECTORY')


class TesOutputFileLog(BaseModel):
    url: str = Field(
        ..., description='URL of the file in storage, e.g. s3://bucket/file.txt'
    )
    path: str = Field(
        ...,
        description='Path of the file inside the container. Must be an absolute path.',
    )
    size_bytes: str = Field(..., description='Size of the file in bytes.')


class TesResources(BaseModel):
    cpu_cores: Optional[int] = Field(None, description='Requested number of CPUs')
    preemptible: Optional[bool] = Field(
        None,
        description='Is the task allowed to run on preemptible compute instances (e.g. AWS Spot)?',
    )
    ram_gb: Optional[float] = Field(
        None, description='Requested RAM required in gigabytes (GB)'
    )
    disk_gb: Optional[float] = Field(
        None, description='Requested disk size in gigabytes (GB)'
    )
    zones: Optional[List[str]] = Field(
        None, description='Request that the task be run in these compute zones.'
    )


class TesServiceInfo(BaseModel):
    name: Optional[str] = Field(
        None, description='Returns the name of the service, e.g. "ohsu-compbio-funnel".'
    )
    doc: Optional[str] = Field(
        None,
        description='Returns a documentation string, e.g. "Hey, we\'re OHSU Comp. Bio!".',
    )
    storage: Optional[List[str]] = Field(
        None,
        description='Lists some, but not necessarily all, storage locations supported by the service.\n\nMust be in a valid URL format.\ne.g. \nfile:///path/to/local/funnel-storage\ns3://ohsu-compbio-funnel/storage\netc.',
    )


class TesState(Enum):
    UNKNOWN = 'UNKNOWN'
    QUEUED = 'QUEUED'
    INITIALIZING = 'INITIALIZING'
    RUNNING = 'RUNNING'
    PAUSED = 'PAUSED'
    COMPLETE = 'COMPLETE'
    EXECUTOR_ERROR = 'EXECUTOR_ERROR'
    SYSTEM_ERROR = 'SYSTEM_ERROR'
    CANCELED = 'CANCELED'


class TesTaskLog(BaseModel):
    logs: List[TesExecutorLog] = Field(..., description='Logs for each executor')
    metadata: Optional[Dict[str, str]] = Field(
        None, description='Arbitrary logging metadata included by the implementation.'
    )
    start_time: Optional[str] = Field(
        None, description='When the task started, in RFC 3339 format.'
    )
    end_time: Optional[str] = Field(
        None, description='When the task ended, in RFC 3339 format.'
    )
    outputs: List[TesOutputFileLog] = Field(
        ...,
        description='Information about all output files. Directory outputs are\nflattened into separate items.',
    )
    system_logs: Optional[List[str]] = Field(
        None,
        description='System logs are any logs the system decides are relevant,\nwhich are not tied directly to an Executor process.\nContent is implementation specific: format, size, etc.\n\nSystem logs may be collected here to provide convenient access.\n\nFor example, the system may include the name of the host\nwhere the task is executing, an error message that caused\na SYSTEM_ERROR state (e.g. disk is full), etc.\n\nSystem logs are only included in the FULL task view.',
    )


class TesTask(BaseModel):
    id: Optional[str] = Field(
        None, description='Task identifier assigned by   the server.'
    )
    state: Optional[TesState] = None
    name: Optional[str] = None
    description: Optional[str] = None
    inputs: Optional[List[TesInput]] = Field(
        None,
        description='Input files.\nInputs will be downloaded and mounted into the executor container.',
    )
    outputs: Optional[List[TesOutput]] = Field(
        None,
        description='Output files.\nOutputs will be uploaded from the executor container to long-term storage.',
    )
    resources: Optional[TesResources] = Field(
        None, description='Request that the task be run with these resources.'
    )
    executors: List[TesExecutor] = Field(
        ...,
        description='A list of executors to be run, sequentially. Execution stops\non the first error.',
    )
    volumes: Optional[List[str]] = Field(
        None,
        description='Volumes are directories which may be used to share data between\nExecutors. Volumes are initialized as empty directories by the\nsystem when the task starts and are mounted at the same path\nin each Executor.\n\nFor example, given a volume defined at "/vol/A",\nexecutor 1 may write a file to "/vol/A/exec1.out.txt", then\nexecutor 2 may read from that file.\n\n(Essentially, this translates to a `docker run -v` flag where\nthe container path is the same for each  executor).',
    )
    tags: Optional[Dict[str, str]] = Field(
        None, description='A key-value map of arbitrary tags.'
    )
    logs: Optional[List[TesTaskLog]] = Field(
        None,
        description='Task logging information.\nNormally, this will contain only one  entry, but in the case where\na task fails and is retried, an entry will be appended to this list.',
    )
    creation_time: Optional[str] = Field(
        None,
        description='Date + time the task was created, in RFC 3339 format.\nThis is set by the system, not the client.',
    )


class TesListTasksResponse(BaseModel):
    tasks: List[TesTask] = Field(..., description='List of tasks.')
    next_page_token: Optional[str] = Field(
        None,
        description='Token used to return the next page of results.\nSee TaskListRequest.next_page_token',
    )
